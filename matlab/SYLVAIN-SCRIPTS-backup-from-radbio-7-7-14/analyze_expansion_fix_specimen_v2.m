% This version creates a contact sheet so one can pick the nuclei to keep
% first. No
target_dir = '/data/Collaborations/Karpen/Master_Joel/Joel/12_15_10_RNAi/deconv_no_frap/brown/';
output_dir = '/data2/home/jswenson/12_15_10_RNAi/';
%target_dir = '/mnt/orona/IRENE/DVdata/10_10_23_NIH3T3_pH2Av_1Gy/Shift_corrected/';
%output_dir = '/data/Images/2010-09-29_NIH3T3
%foci+het_expt#5/1Gy/ap101020ap/DVset/';
% target_dir = '/data/Images/2010-09-29_NIH3T3 foci+het_expt#5/1Gy/ap101020ap/SubTest/';
% output_dir = '/data/Images/2010-09-29_NIH3T3 foci+het_expt#5/1Gy/ap101020ap/SubTest/'
% target_dir = '/mnt/orona/IRENE/DVdata/10_10_18_DAPI_bright/Smc5_6_30min/';
% output_dir = '/data/Collaborations/Irene/DAPI_bright_10_15_2010/'
%output_dir = '/mnt/orona/IRENE/DVdata/Paper_9_12_08_Kinetic_Kc/TdT/DAPI-bright/';
% target_dir ='\\radbio\data\Collaborations\Irene\expansion_fix_specimen\';
% output_dir ='\\radbio\data\Collaborations\Irene\expansion_fix_specimen\';
str_output = 'DAPI_BRIGHT';
clear ms_nuc; % make sure no previous record
if isunix
    slash_str = '/';
else
    slash_str = '\';
end
normalized = 0; % If positive, then load ics files generated by Imaris for normalization
append_mode = 0; % Set it to one if you want to restart from a given image
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PARAMETERS SETTINGS %%%%%%%%%%%%%%%%%%%
nuc_rad = 30; % size for segmenting nuclei. If nuclei come out split, parameter is too small.
nuc_chan = 3;
img_format = '.dv'; %PUt dv for deltavision
db_size = 15; % Approximate diameter of DAPI BRIGHT domains
if normalized
    list = dir([target_dir '*.ics']);
else
    list = dir([target_dir '*' img_format]);
end
cd(output_dir)
mkdir(str_output);
output_dir = [output_dir str_output slash_str];

% Start 0pening files
if append_mode
    ofp = fopen([output_dir 'size_summary.xls'],'a');
    ini_img =inputdlg('Enter starting image #','You are appending to existing file');
    ini_img = str2double(ini_img);
else
    ofp = fopen([output_dir 'size_summary.xls'],'w');
    fprintf(ofp,'Image#\tNucleus#\tNucleusVolume\tDBVolume\tNumberofDB\n');
    ini_img=1;
end
num_img = length(list);
for i_img = ini_img:num_img
    fprintf('Processing img#%d: %s\n',i_img,list(i_img).name)
    if normalized
        img = readim([target_dir list(i_img).name]);
        img = squeeze(img);
    else
        [img,metadata] = bfopen3([target_dir list(i_img).name]);
        nuc = img{nuc_chan};
        
        % Make sure x,y scale not overkill. Anything below 0.15
        % um is set to 0.13
        dxy = metadata.get('Scale Factor for X');
        dz = metadata.get('Scale Factor for Z');
        if isempty(dxy) % For different deltavision version
            dxy = metadata.get('Y element length (in um)');
            dz = metadata.get('Z element length (in um)');
        end
        if isstr(dxy)
            dxy = str2num(dxy);
        end
        if isstr(dz)
            dz = str2num(dz);
        end
    end
    % segment nuclei manually
    mask = nuc_segmentor_lite3(nuc,nuc_rad,2,[],1,0);
    nuc2D = squeeze(max(nuc,[],3));
    %     dipshow(100,nuc2D,'lin');
    %     set(gcf,'Position',[20,300,300,300])
    %     diptruesize(50)
    %     roi_flag = 1;
    %     while roi_flag % Confirm with users threshold is right
    %         sm_mask = dipcrop;
    %         [o,t]=threshold(sm_mask);
    %         edge = squeeze(nuc2D>t);
    %         edge = bdilation(edge)-edge;
    %         dipshow(overlay(stretch(nuc2D),edge,[0,0,255]),'lin');
    %         set(gcf,'Position',[20,300,300,300])
    %         diptruesize(50)
    %         ButtonName = questdlg('Keep mask?','Confirm Mask');
    %         switch ButtonName
    %             case 'Yes'
    %                 mask = nuc>t;
    %                 %Remove edge nuc
    %                 mask(:,0,:) = 1; % Will get rid of anything on edge
    %                 mask(0,:,:) = 1;
    %                 mask(:,end,:) = 1;
    %                 mask(end,:,:) = 1;
    %                 mask = label(mask>0) > 1;
    %                 mask = label(and(mask,nuc>t),3,round(pi*nuc_rad^2),10000000);
    %                 roi_flag = 0;
    %             otherwise
    %         end
    %         delete(gcf)
    %     end
    db_mask = newim(size(mask));
    num_nuc = max(mask);
    num_db_obj = zeros(1,num_nuc); % Store the number of DB objects in each nucleus
    for i =1:num_nuc % loop on each nucleus and let user select ROI where DB boundary is located
        [crop_nuc,coords] = crop_from_mask(nuc,mask==i,3);
        crop_top = map('tophat',crop_nuc,num2str(db_size));
        crop_mask = mask(coords(1,1):coords(1,2),coords(2,1):coords(2,2),coords(3,1):coords(3,2));
        t = median(crop_nuc(crop_mask==i)); % figure out threshold that was used to get such mask
        nuc2D = squeeze(max(crop_nuc,[],3));
        nuc_adjust = 1;
        while nuc_adjust % delete nuclei or adjust nuclei boundaries
            edge_mask = squeeze(max(crop_mask,[],3))>0;
            edge_mask = edge_mask - berosion(edge_mask);
            dipshow(100,overlay(stretch(nuc2D),edge_mask));
            diptruesize(200);
            waitfor(100, 'CurrentCharacter');
            key_press = get(100, 'CurrentCharacter');
            switch key_press
                case 'd'
                    t = 0.95*t;
                    set(100,'CurrentCharacter','o'); %force change to allow constant update
                    crop_mask = crop_nuc>t;
                case 'f'
                    t = 1.05*t;
                    set(100,'CurrentCharacter','o'); %force change to allow constant update
                    crop_mask = crop_nuc>t;
                case 'k' % delete this cell
                    nuc_adjust = 0;
                    mask(mask==i) = 0; % just put a blank mask for this one nuc
                    set(100,'CurrentCharacter','o'); %force change to allow constant update
                    roi_flag = 0; % Do not work on this nuc anymore
                    key_press = 'o';
                case 'q'
                    crop_mask = label(crop_mask,3,10,100000000);
                    ms = measure(crop_mask,[],'size');
                    [mx_size,mx_ind]=max(ms.size);
                    crop_mask = (crop_mask == ms.ID(mx_ind))*i;
                    mask(mask==i) = 0; % delete old nucleus
                    mask = insert_crop(crop_mask,mask,coords,'add'); %Add new nucleus in
                    nuc_adjust = 0;
                    set(100,'CurrentCharacter','o'); %force change to allow constant update
                    roi_flag = 1;
                    dipshow(100,nuc2D,'lin');
                    set(gcf,'Position',[20,300,300,300])
                    diptruesize(400)
                    keyboard_mode = 0;
            end
        end
 % Segment DAPI Bright
        while roi_flag % Confirm with users threshold is right
            switch keyboard_mode % Switch on keyboard mode
                case 0 % keyboard_mode off
                    [sm_mask,cropC] = dipcrop;
                    sm_mask = crop_top(cropC(1,1):cropC(1,1)+cropC(2,1),cropC(1,2):cropC(1,2)+cropC(2,2),:);
                    [o,t]=threshold(sm_mask);
                    edge = squeeze(max(crop_top>t,[],3));
                    edge = bdilation(edge)-edge;
                    dipshow(101,overlay(stretch(nuc2D),edge,[0,0,255]),'lin');
                    set(gcf,'Position',[20,300,300,300])
                    diptruesize(400)
                    ButtonName = questdlg('Keep mask?','Confirm Mask');
                    switch ButtonName
                        case 'Yes'
                            sm_db = and(crop_top>t,crop_mask==i);
                            num_db_obj(i) = max(label(sm_db,3,10,10000000));
                            db_mask = insert_crop(sm_db,db_mask,coords);
                            roi_flag = 0;
                        otherwise
                            keyboard_mode = 1;
                            delete(100);
                    end
                otherwise % keyboard_mode on
                    %key_press = lower(input('','s'));
                    waitfor(101, 'CurrentCharacter');
                    key_press = get(101, 'CurrentCharacter');
                    %fprintf('%s\n',key_press);
                    switch key_press
                        case 'd'
                            t = 0.95*t;
                            set(101,'CurrentCharacter','o'); %force change to allow constant update
                        case 'f'
                            t = 1.05*t;
                            set(101,'CurrentCharacter','o'); %force change to allow constant update
                        case 'k' % delete this cell
                            roi_flag = 0;
                            mask(mask==i) = 0;
                            key_press = 'o';
                        case 'q'
                            sm_db = and(crop_top>t,crop_mask==i);
                            num_db_obj(i) = max(label(sm_db,3,10,10000000));
                            db_mask = insert_crop(sm_db,db_mask,coords);
                            roi_flag = 0;
                    end
                    edge = squeeze(max(crop_top>t,[],3));
                    edge = bdilation(edge)-edge;
                    dipshow(101,overlay(stretch(nuc2D),edge,[0,0,255]),'lin');
                    set(gcf,'Position',[20,300,300,300])
                    diptruesize(400)
            end % keyboard switch
         end
        delete(gcf)
    end
    %OUTPUT
    % Measurements
    mask(mask>num_nuc) = 0; % This removes any nuclei that got incremented partly due to pasting back a square ROI
    db_mask = and(db_mask,mask>0); % Only keep DB in segmented nuclei...
    % Remove nuclei masks that have lost (bug) their DB mask and save the
    % rest
    ms = measure(mask,db_mask*1.0,{'size','sum'});
    rem_ind = find(ms.sum==0);
    for i_rem = 1:length(rem_ind)
        mask(mask==i_rem) = 0;
    end
    ms = measure(mask,db_mask*1.0,{'size','sum'});
    ms_nuc.img = repmat({list(i_img).name(1:end-3)},1,length(ms.ID));
    ms_nuc.ID = ms.ID;
    ms_nuc.nV = ms.size*dxy^2*dz;
    ms_nuc.nD = ms.sum*dxy^2*dz;
    ms_nuc.numOfDB = num_db_obj(ms.ID);
    struct_print(ofp,ms_nuc,0);
    % Overlay image
    % create 2D projections
    mask2D = squeeze(max(mask,[],3)); db_mask2D = squeeze(max(db_mask,[],3)); nuc2D = squeeze(max(nuc,[],3));
    ms = measure(mask2D,[],'Minimum');
    % create nuc boundary
    edge = newim(size(mask2D));
    edge = (insert_crop(mask2D(1:end,:),edge,[0,size(mask2D,1)-2;0,size(mask2D,2)-1]) - mask2D)^2 + ...
        (insert_crop(mask2D(:,1:end),edge,[0,size(mask2D,1)-1;0,size(mask2D,2)-2]) - mask2D)^2;
    nuc_edge = edge>0;
    overlay_img = overlay(stretch(nuc2D),nuc_edge,[0 0 255]);
    % create Dapi Bright boundaries
    edge(:) = 0;
    edge = (insert_crop(db_mask2D(1:end,:),edge,[0,size(db_mask2D,1)-2;0,size(db_mask2D,2)-1]) - db_mask2D)^2 + ...
        (insert_crop(db_mask2D(:,1:end),edge,[0,size(db_mask2D,1)-1;0,size(db_mask2D,2)-2]) - db_mask2D)^2;
    db_edge = edge>0;
    overlay_img = overlay(overlay_img,db_edge,[0 255 0])
    % Label nuclei with their numbers
    for i_label=1:size(ms,1)
        minC = ms.Minimum;
        text(minC(1,i_label),minC(2,i_label),sprintf('%d',ms.ID(i_label)),'color','yellow','FontSize',10)
    end
    diptruesize(gcf,70)
    saveas(gcf,[output_dir list(i_img).name(1:end-3) '_Check.tif'],'tif');
    delete(gcf);
    % Mask image
    mask = dip_image(uint16(mask));
    writeim(db_mask,[output_dir list(i_img).name(1:end-3) '_DB_mask.ics'],'ICSv1',0);
    writeim(mask,[output_dir list(i_img).name(1:end-3) '_nuc_mask.ics'],'ICSv1',0);
end
delete(gcf)
fclose('all');